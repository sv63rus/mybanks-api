// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"mybanks-api/ent"
	"mybanks-api/ent/bank"
	"mybanks-api/ent/currencyrate"
	"mybanks-api/ent/offer"

	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateBank handles POST /banks requests.
func (h *OgentHandler) CreateBank(ctx context.Context, req *CreateBankReq) (CreateBankRes, error) {
	b := h.client.Bank.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetCountry(req.Country)
	if v, ok := req.Website.Get(); ok {
		b.SetWebsite(v)
	}
	if v, ok := req.LogoURL.Get(); ok {
		b.SetLogoURL(v)
	}
	if v, ok := req.Test.Get(); ok {
		b.SetTest(v)
	}
	// Add all edges.
	b.AddCurrencyRateIDs(req.CurrencyRates...)
	b.AddOfferIDs(req.Offers...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Bank.Query().Where(bank.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBankCreate(e), nil
}

// ReadBank handles GET /banks/{id} requests.
func (h *OgentHandler) ReadBank(ctx context.Context, params ReadBankParams) (ReadBankRes, error) {
	q := h.client.Bank.Query().Where(bank.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBankRead(e), nil
}

// UpdateBank handles PATCH /banks/{id} requests.
func (h *OgentHandler) UpdateBank(ctx context.Context, req *UpdateBankReq, params UpdateBankParams) (UpdateBankRes, error) {
	b := h.client.Bank.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Country.Get(); ok {
		b.SetCountry(v)
	}
	if v, ok := req.Website.Get(); ok {
		b.SetWebsite(v)
	}
	if v, ok := req.LogoURL.Get(); ok {
		b.SetLogoURL(v)
	}
	if v, ok := req.Test.Get(); ok {
		b.SetTest(v)
	}
	// Add all edges.
	if req.CurrencyRates != nil {
		b.ClearCurrencyRates().AddCurrencyRateIDs(req.CurrencyRates...)
	}
	if req.Offers != nil {
		b.ClearOffers().AddOfferIDs(req.Offers...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Bank.Query().Where(bank.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBankUpdate(e), nil
}

// DeleteBank handles DELETE /banks/{id} requests.
func (h *OgentHandler) DeleteBank(ctx context.Context, params DeleteBankParams) (DeleteBankRes, error) {
	err := h.client.Bank.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteBankNoContent), nil

}

// ListBank handles GET /banks requests.
func (h *OgentHandler) ListBank(ctx context.Context, params ListBankParams) (ListBankRes, error) {
	q := h.client.Bank.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBankLists(es)
	return (*ListBankOKApplicationJSON)(&r), nil
}

// ListBankCurrencyRates handles GET /banks/{id}/currency-rates requests.
func (h *OgentHandler) ListBankCurrencyRates(ctx context.Context, params ListBankCurrencyRatesParams) (ListBankCurrencyRatesRes, error) {
	q := h.client.Bank.Query().Where(bank.IDEQ(params.ID)).QueryCurrencyRates()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBankCurrencyRatesLists(es)
	return (*ListBankCurrencyRatesOKApplicationJSON)(&r), nil
}

// ListBankOffers handles GET /banks/{id}/offers requests.
func (h *OgentHandler) ListBankOffers(ctx context.Context, params ListBankOffersParams) (ListBankOffersRes, error) {
	q := h.client.Bank.Query().Where(bank.IDEQ(params.ID)).QueryOffers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBankOffersLists(es)
	return (*ListBankOffersOKApplicationJSON)(&r), nil
}

// CreateCurrencyRate handles POST /currency-rates requests.
func (h *OgentHandler) CreateCurrencyRate(ctx context.Context, req *CreateCurrencyRateReq) (CreateCurrencyRateRes, error) {
	b := h.client.CurrencyRate.Create()
	// Add all fields.
	b.SetCurrency(req.Currency)
	b.SetRate(req.Rate)
	// Add all edges.
	b.SetBankID(req.Bank)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.CurrencyRate.Query().Where(currencyrate.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCurrencyRateCreate(e), nil
}

// ReadCurrencyRate handles GET /currency-rates/{id} requests.
func (h *OgentHandler) ReadCurrencyRate(ctx context.Context, params ReadCurrencyRateParams) (ReadCurrencyRateRes, error) {
	q := h.client.CurrencyRate.Query().Where(currencyrate.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCurrencyRateRead(e), nil
}

// UpdateCurrencyRate handles PATCH /currency-rates/{id} requests.
func (h *OgentHandler) UpdateCurrencyRate(ctx context.Context, req *UpdateCurrencyRateReq, params UpdateCurrencyRateParams) (UpdateCurrencyRateRes, error) {
	b := h.client.CurrencyRate.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Currency.Get(); ok {
		b.SetCurrency(v)
	}
	if v, ok := req.Rate.Get(); ok {
		b.SetRate(v)
	}
	// Add all edges.
	if v, ok := req.Bank.Get(); ok {
		b.SetBankID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.CurrencyRate.Query().Where(currencyrate.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCurrencyRateUpdate(e), nil
}

// DeleteCurrencyRate handles DELETE /currency-rates/{id} requests.
func (h *OgentHandler) DeleteCurrencyRate(ctx context.Context, params DeleteCurrencyRateParams) (DeleteCurrencyRateRes, error) {
	err := h.client.CurrencyRate.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCurrencyRateNoContent), nil

}

// ListCurrencyRate handles GET /currency-rates requests.
func (h *OgentHandler) ListCurrencyRate(ctx context.Context, params ListCurrencyRateParams) (ListCurrencyRateRes, error) {
	q := h.client.CurrencyRate.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCurrencyRateLists(es)
	return (*ListCurrencyRateOKApplicationJSON)(&r), nil
}

// ReadCurrencyRateBank handles GET /currency-rates/{id}/bank requests.
func (h *OgentHandler) ReadCurrencyRateBank(ctx context.Context, params ReadCurrencyRateBankParams) (ReadCurrencyRateBankRes, error) {
	q := h.client.CurrencyRate.Query().Where(currencyrate.IDEQ(params.ID)).QueryBank()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCurrencyRateBankRead(e), nil
}

// CreateOffer handles POST /offers requests.
func (h *OgentHandler) CreateOffer(ctx context.Context, req *CreateOfferReq) (CreateOfferRes, error) {
	b := h.client.Offer.Create()
	// Add all fields.
	b.SetType(req.Type)
	b.SetDescription(req.Description)
	b.SetLink(req.Link)
	// Add all edges.
	b.SetBankID(req.Bank)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Offer.Query().Where(offer.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewOfferCreate(e), nil
}

// ReadOffer handles GET /offers/{id} requests.
func (h *OgentHandler) ReadOffer(ctx context.Context, params ReadOfferParams) (ReadOfferRes, error) {
	q := h.client.Offer.Query().Where(offer.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewOfferRead(e), nil
}

// UpdateOffer handles PATCH /offers/{id} requests.
func (h *OgentHandler) UpdateOffer(ctx context.Context, req *UpdateOfferReq, params UpdateOfferParams) (UpdateOfferRes, error) {
	b := h.client.Offer.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Type.Get(); ok {
		b.SetType(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.Link.Get(); ok {
		b.SetLink(v)
	}
	// Add all edges.
	if v, ok := req.Bank.Get(); ok {
		b.SetBankID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Offer.Query().Where(offer.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewOfferUpdate(e), nil
}

// DeleteOffer handles DELETE /offers/{id} requests.
func (h *OgentHandler) DeleteOffer(ctx context.Context, params DeleteOfferParams) (DeleteOfferRes, error) {
	err := h.client.Offer.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteOfferNoContent), nil

}

// ListOffer handles GET /offers requests.
func (h *OgentHandler) ListOffer(ctx context.Context, params ListOfferParams) (ListOfferRes, error) {
	q := h.client.Offer.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewOfferLists(es)
	return (*ListOfferOKApplicationJSON)(&r), nil
}

// ReadOfferBank handles GET /offers/{id}/bank requests.
func (h *OgentHandler) ReadOfferBank(ctx context.Context, params ReadOfferBankParams) (ReadOfferBankRes, error) {
	q := h.client.Offer.Query().Where(offer.IDEQ(params.ID)).QueryBank()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewOfferBankRead(e), nil
}
