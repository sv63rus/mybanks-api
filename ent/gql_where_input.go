// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"mybanks-api/ent/bank"
	"mybanks-api/ent/currencyrate"
	"mybanks-api/ent/offer"
	"mybanks-api/ent/predicate"
)

// BankWhereInput represents a where input for filtering Bank queries.
type BankWhereInput struct {
	Predicates []predicate.Bank  `json:"-"`
	Not        *BankWhereInput   `json:"not,omitempty"`
	Or         []*BankWhereInput `json:"or,omitempty"`
	And        []*BankWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "website" field predicates.
	Website             *string  `json:"website,omitempty"`
	WebsiteNEQ          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGT           *string  `json:"websiteGT,omitempty"`
	WebsiteGTE          *string  `json:"websiteGTE,omitempty"`
	WebsiteLT           *string  `json:"websiteLT,omitempty"`
	WebsiteLTE          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        bool     `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       bool     `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`

	// "logo_url" field predicates.
	LogoURL             *string  `json:"logoURL,omitempty"`
	LogoURLNEQ          *string  `json:"logoURLNEQ,omitempty"`
	LogoURLIn           []string `json:"logoURLIn,omitempty"`
	LogoURLNotIn        []string `json:"logoURLNotIn,omitempty"`
	LogoURLGT           *string  `json:"logoURLGT,omitempty"`
	LogoURLGTE          *string  `json:"logoURLGTE,omitempty"`
	LogoURLLT           *string  `json:"logoURLLT,omitempty"`
	LogoURLLTE          *string  `json:"logoURLLTE,omitempty"`
	LogoURLContains     *string  `json:"logoURLContains,omitempty"`
	LogoURLHasPrefix    *string  `json:"logoURLHasPrefix,omitempty"`
	LogoURLHasSuffix    *string  `json:"logoURLHasSuffix,omitempty"`
	LogoURLIsNil        bool     `json:"logoURLIsNil,omitempty"`
	LogoURLNotNil       bool     `json:"logoURLNotNil,omitempty"`
	LogoURLEqualFold    *string  `json:"logoURLEqualFold,omitempty"`
	LogoURLContainsFold *string  `json:"logoURLContainsFold,omitempty"`

	// "currency_rates" edge predicates.
	HasCurrencyRates     *bool                     `json:"hasCurrencyRates,omitempty"`
	HasCurrencyRatesWith []*CurrencyRateWhereInput `json:"hasCurrencyRatesWith,omitempty"`

	// "offers" edge predicates.
	HasOffers     *bool              `json:"hasOffers,omitempty"`
	HasOffersWith []*OfferWhereInput `json:"hasOffersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BankWhereInput) AddPredicates(predicates ...predicate.Bank) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BankWhereInput filter on the BankQuery builder.
func (i *BankWhereInput) Filter(q *BankQuery) (*BankQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBankWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBankWhereInput is returned in case the BankWhereInput is empty.
var ErrEmptyBankWhereInput = errors.New("ent: empty predicate BankWhereInput")

// P returns a predicate for filtering banks.
// An error is returned if the input is empty or invalid.
func (i *BankWhereInput) P() (predicate.Bank, error) {
	var predicates []predicate.Bank
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bank.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Bank, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bank.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Bank, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bank.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bank.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bank.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bank.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bank.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bank.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bank.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bank.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bank.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, bank.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, bank.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, bank.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, bank.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, bank.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, bank.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, bank.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, bank.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, bank.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, bank.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, bank.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, bank.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, bank.NameContainsFold(*i.NameContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, bank.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, bank.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, bank.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, bank.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, bank.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, bank.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, bank.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, bank.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, bank.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, bank.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, bank.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, bank.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, bank.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Website != nil {
		predicates = append(predicates, bank.WebsiteEQ(*i.Website))
	}
	if i.WebsiteNEQ != nil {
		predicates = append(predicates, bank.WebsiteNEQ(*i.WebsiteNEQ))
	}
	if len(i.WebsiteIn) > 0 {
		predicates = append(predicates, bank.WebsiteIn(i.WebsiteIn...))
	}
	if len(i.WebsiteNotIn) > 0 {
		predicates = append(predicates, bank.WebsiteNotIn(i.WebsiteNotIn...))
	}
	if i.WebsiteGT != nil {
		predicates = append(predicates, bank.WebsiteGT(*i.WebsiteGT))
	}
	if i.WebsiteGTE != nil {
		predicates = append(predicates, bank.WebsiteGTE(*i.WebsiteGTE))
	}
	if i.WebsiteLT != nil {
		predicates = append(predicates, bank.WebsiteLT(*i.WebsiteLT))
	}
	if i.WebsiteLTE != nil {
		predicates = append(predicates, bank.WebsiteLTE(*i.WebsiteLTE))
	}
	if i.WebsiteContains != nil {
		predicates = append(predicates, bank.WebsiteContains(*i.WebsiteContains))
	}
	if i.WebsiteHasPrefix != nil {
		predicates = append(predicates, bank.WebsiteHasPrefix(*i.WebsiteHasPrefix))
	}
	if i.WebsiteHasSuffix != nil {
		predicates = append(predicates, bank.WebsiteHasSuffix(*i.WebsiteHasSuffix))
	}
	if i.WebsiteIsNil {
		predicates = append(predicates, bank.WebsiteIsNil())
	}
	if i.WebsiteNotNil {
		predicates = append(predicates, bank.WebsiteNotNil())
	}
	if i.WebsiteEqualFold != nil {
		predicates = append(predicates, bank.WebsiteEqualFold(*i.WebsiteEqualFold))
	}
	if i.WebsiteContainsFold != nil {
		predicates = append(predicates, bank.WebsiteContainsFold(*i.WebsiteContainsFold))
	}
	if i.LogoURL != nil {
		predicates = append(predicates, bank.LogoURLEQ(*i.LogoURL))
	}
	if i.LogoURLNEQ != nil {
		predicates = append(predicates, bank.LogoURLNEQ(*i.LogoURLNEQ))
	}
	if len(i.LogoURLIn) > 0 {
		predicates = append(predicates, bank.LogoURLIn(i.LogoURLIn...))
	}
	if len(i.LogoURLNotIn) > 0 {
		predicates = append(predicates, bank.LogoURLNotIn(i.LogoURLNotIn...))
	}
	if i.LogoURLGT != nil {
		predicates = append(predicates, bank.LogoURLGT(*i.LogoURLGT))
	}
	if i.LogoURLGTE != nil {
		predicates = append(predicates, bank.LogoURLGTE(*i.LogoURLGTE))
	}
	if i.LogoURLLT != nil {
		predicates = append(predicates, bank.LogoURLLT(*i.LogoURLLT))
	}
	if i.LogoURLLTE != nil {
		predicates = append(predicates, bank.LogoURLLTE(*i.LogoURLLTE))
	}
	if i.LogoURLContains != nil {
		predicates = append(predicates, bank.LogoURLContains(*i.LogoURLContains))
	}
	if i.LogoURLHasPrefix != nil {
		predicates = append(predicates, bank.LogoURLHasPrefix(*i.LogoURLHasPrefix))
	}
	if i.LogoURLHasSuffix != nil {
		predicates = append(predicates, bank.LogoURLHasSuffix(*i.LogoURLHasSuffix))
	}
	if i.LogoURLIsNil {
		predicates = append(predicates, bank.LogoURLIsNil())
	}
	if i.LogoURLNotNil {
		predicates = append(predicates, bank.LogoURLNotNil())
	}
	if i.LogoURLEqualFold != nil {
		predicates = append(predicates, bank.LogoURLEqualFold(*i.LogoURLEqualFold))
	}
	if i.LogoURLContainsFold != nil {
		predicates = append(predicates, bank.LogoURLContainsFold(*i.LogoURLContainsFold))
	}

	if i.HasCurrencyRates != nil {
		p := bank.HasCurrencyRates()
		if !*i.HasCurrencyRates {
			p = bank.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCurrencyRatesWith) > 0 {
		with := make([]predicate.CurrencyRate, 0, len(i.HasCurrencyRatesWith))
		for _, w := range i.HasCurrencyRatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCurrencyRatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bank.HasCurrencyRatesWith(with...))
	}
	if i.HasOffers != nil {
		p := bank.HasOffers()
		if !*i.HasOffers {
			p = bank.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOffersWith) > 0 {
		with := make([]predicate.Offer, 0, len(i.HasOffersWith))
		for _, w := range i.HasOffersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOffersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bank.HasOffersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBankWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bank.And(predicates...), nil
	}
}

// CurrencyRateWhereInput represents a where input for filtering CurrencyRate queries.
type CurrencyRateWhereInput struct {
	Predicates []predicate.CurrencyRate  `json:"-"`
	Not        *CurrencyRateWhereInput   `json:"not,omitempty"`
	Or         []*CurrencyRateWhereInput `json:"or,omitempty"`
	And        []*CurrencyRateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "currency" field predicates.
	Currency             *string  `json:"currency,omitempty"`
	CurrencyNEQ          *string  `json:"currencyNEQ,omitempty"`
	CurrencyIn           []string `json:"currencyIn,omitempty"`
	CurrencyNotIn        []string `json:"currencyNotIn,omitempty"`
	CurrencyGT           *string  `json:"currencyGT,omitempty"`
	CurrencyGTE          *string  `json:"currencyGTE,omitempty"`
	CurrencyLT           *string  `json:"currencyLT,omitempty"`
	CurrencyLTE          *string  `json:"currencyLTE,omitempty"`
	CurrencyContains     *string  `json:"currencyContains,omitempty"`
	CurrencyHasPrefix    *string  `json:"currencyHasPrefix,omitempty"`
	CurrencyHasSuffix    *string  `json:"currencyHasSuffix,omitempty"`
	CurrencyEqualFold    *string  `json:"currencyEqualFold,omitempty"`
	CurrencyContainsFold *string  `json:"currencyContainsFold,omitempty"`

	// "rate" field predicates.
	Rate      *float64  `json:"rate,omitempty"`
	RateNEQ   *float64  `json:"rateNEQ,omitempty"`
	RateIn    []float64 `json:"rateIn,omitempty"`
	RateNotIn []float64 `json:"rateNotIn,omitempty"`
	RateGT    *float64  `json:"rateGT,omitempty"`
	RateGTE   *float64  `json:"rateGTE,omitempty"`
	RateLT    *float64  `json:"rateLT,omitempty"`
	RateLTE   *float64  `json:"rateLTE,omitempty"`

	// "bank" edge predicates.
	HasBank     *bool             `json:"hasBank,omitempty"`
	HasBankWith []*BankWhereInput `json:"hasBankWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CurrencyRateWhereInput) AddPredicates(predicates ...predicate.CurrencyRate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CurrencyRateWhereInput filter on the CurrencyRateQuery builder.
func (i *CurrencyRateWhereInput) Filter(q *CurrencyRateQuery) (*CurrencyRateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCurrencyRateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCurrencyRateWhereInput is returned in case the CurrencyRateWhereInput is empty.
var ErrEmptyCurrencyRateWhereInput = errors.New("ent: empty predicate CurrencyRateWhereInput")

// P returns a predicate for filtering currencyrates.
// An error is returned if the input is empty or invalid.
func (i *CurrencyRateWhereInput) P() (predicate.CurrencyRate, error) {
	var predicates []predicate.CurrencyRate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, currencyrate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CurrencyRate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, currencyrate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CurrencyRate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, currencyrate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, currencyrate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, currencyrate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, currencyrate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, currencyrate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, currencyrate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, currencyrate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, currencyrate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, currencyrate.IDLTE(*i.IDLTE))
	}
	if i.Currency != nil {
		predicates = append(predicates, currencyrate.CurrencyEQ(*i.Currency))
	}
	if i.CurrencyNEQ != nil {
		predicates = append(predicates, currencyrate.CurrencyNEQ(*i.CurrencyNEQ))
	}
	if len(i.CurrencyIn) > 0 {
		predicates = append(predicates, currencyrate.CurrencyIn(i.CurrencyIn...))
	}
	if len(i.CurrencyNotIn) > 0 {
		predicates = append(predicates, currencyrate.CurrencyNotIn(i.CurrencyNotIn...))
	}
	if i.CurrencyGT != nil {
		predicates = append(predicates, currencyrate.CurrencyGT(*i.CurrencyGT))
	}
	if i.CurrencyGTE != nil {
		predicates = append(predicates, currencyrate.CurrencyGTE(*i.CurrencyGTE))
	}
	if i.CurrencyLT != nil {
		predicates = append(predicates, currencyrate.CurrencyLT(*i.CurrencyLT))
	}
	if i.CurrencyLTE != nil {
		predicates = append(predicates, currencyrate.CurrencyLTE(*i.CurrencyLTE))
	}
	if i.CurrencyContains != nil {
		predicates = append(predicates, currencyrate.CurrencyContains(*i.CurrencyContains))
	}
	if i.CurrencyHasPrefix != nil {
		predicates = append(predicates, currencyrate.CurrencyHasPrefix(*i.CurrencyHasPrefix))
	}
	if i.CurrencyHasSuffix != nil {
		predicates = append(predicates, currencyrate.CurrencyHasSuffix(*i.CurrencyHasSuffix))
	}
	if i.CurrencyEqualFold != nil {
		predicates = append(predicates, currencyrate.CurrencyEqualFold(*i.CurrencyEqualFold))
	}
	if i.CurrencyContainsFold != nil {
		predicates = append(predicates, currencyrate.CurrencyContainsFold(*i.CurrencyContainsFold))
	}
	if i.Rate != nil {
		predicates = append(predicates, currencyrate.RateEQ(*i.Rate))
	}
	if i.RateNEQ != nil {
		predicates = append(predicates, currencyrate.RateNEQ(*i.RateNEQ))
	}
	if len(i.RateIn) > 0 {
		predicates = append(predicates, currencyrate.RateIn(i.RateIn...))
	}
	if len(i.RateNotIn) > 0 {
		predicates = append(predicates, currencyrate.RateNotIn(i.RateNotIn...))
	}
	if i.RateGT != nil {
		predicates = append(predicates, currencyrate.RateGT(*i.RateGT))
	}
	if i.RateGTE != nil {
		predicates = append(predicates, currencyrate.RateGTE(*i.RateGTE))
	}
	if i.RateLT != nil {
		predicates = append(predicates, currencyrate.RateLT(*i.RateLT))
	}
	if i.RateLTE != nil {
		predicates = append(predicates, currencyrate.RateLTE(*i.RateLTE))
	}

	if i.HasBank != nil {
		p := currencyrate.HasBank()
		if !*i.HasBank {
			p = currencyrate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBankWith) > 0 {
		with := make([]predicate.Bank, 0, len(i.HasBankWith))
		for _, w := range i.HasBankWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBankWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, currencyrate.HasBankWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCurrencyRateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return currencyrate.And(predicates...), nil
	}
}

// OfferWhereInput represents a where input for filtering Offer queries.
type OfferWhereInput struct {
	Predicates []predicate.Offer  `json:"-"`
	Not        *OfferWhereInput   `json:"not,omitempty"`
	Or         []*OfferWhereInput `json:"or,omitempty"`
	And        []*OfferWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "link" field predicates.
	Link             *string  `json:"link,omitempty"`
	LinkNEQ          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGT           *string  `json:"linkGT,omitempty"`
	LinkGTE          *string  `json:"linkGTE,omitempty"`
	LinkLT           *string  `json:"linkLT,omitempty"`
	LinkLTE          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`

	// "bank" edge predicates.
	HasBank     *bool             `json:"hasBank,omitempty"`
	HasBankWith []*BankWhereInput `json:"hasBankWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OfferWhereInput) AddPredicates(predicates ...predicate.Offer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OfferWhereInput filter on the OfferQuery builder.
func (i *OfferWhereInput) Filter(q *OfferQuery) (*OfferQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOfferWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOfferWhereInput is returned in case the OfferWhereInput is empty.
var ErrEmptyOfferWhereInput = errors.New("ent: empty predicate OfferWhereInput")

// P returns a predicate for filtering offers.
// An error is returned if the input is empty or invalid.
func (i *OfferWhereInput) P() (predicate.Offer, error) {
	var predicates []predicate.Offer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, offer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Offer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, offer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Offer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, offer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, offer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, offer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, offer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, offer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, offer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, offer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, offer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, offer.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, offer.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, offer.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, offer.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, offer.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, offer.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, offer.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, offer.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, offer.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, offer.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, offer.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, offer.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, offer.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, offer.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, offer.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, offer.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, offer.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, offer.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, offer.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, offer.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, offer.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, offer.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, offer.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, offer.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, offer.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, offer.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, offer.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Link != nil {
		predicates = append(predicates, offer.LinkEQ(*i.Link))
	}
	if i.LinkNEQ != nil {
		predicates = append(predicates, offer.LinkNEQ(*i.LinkNEQ))
	}
	if len(i.LinkIn) > 0 {
		predicates = append(predicates, offer.LinkIn(i.LinkIn...))
	}
	if len(i.LinkNotIn) > 0 {
		predicates = append(predicates, offer.LinkNotIn(i.LinkNotIn...))
	}
	if i.LinkGT != nil {
		predicates = append(predicates, offer.LinkGT(*i.LinkGT))
	}
	if i.LinkGTE != nil {
		predicates = append(predicates, offer.LinkGTE(*i.LinkGTE))
	}
	if i.LinkLT != nil {
		predicates = append(predicates, offer.LinkLT(*i.LinkLT))
	}
	if i.LinkLTE != nil {
		predicates = append(predicates, offer.LinkLTE(*i.LinkLTE))
	}
	if i.LinkContains != nil {
		predicates = append(predicates, offer.LinkContains(*i.LinkContains))
	}
	if i.LinkHasPrefix != nil {
		predicates = append(predicates, offer.LinkHasPrefix(*i.LinkHasPrefix))
	}
	if i.LinkHasSuffix != nil {
		predicates = append(predicates, offer.LinkHasSuffix(*i.LinkHasSuffix))
	}
	if i.LinkEqualFold != nil {
		predicates = append(predicates, offer.LinkEqualFold(*i.LinkEqualFold))
	}
	if i.LinkContainsFold != nil {
		predicates = append(predicates, offer.LinkContainsFold(*i.LinkContainsFold))
	}

	if i.HasBank != nil {
		p := offer.HasBank()
		if !*i.HasBank {
			p = offer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBankWith) > 0 {
		with := make([]predicate.Bank, 0, len(i.HasBankWith))
		for _, w := range i.HasBankWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBankWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, offer.HasBankWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOfferWhereInput
	case 1:
		return predicates[0], nil
	default:
		return offer.And(predicates...), nil
	}
}
